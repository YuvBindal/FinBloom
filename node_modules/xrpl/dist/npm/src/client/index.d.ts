/// <reference types="node" />
import { EventEmitter } from 'events';
import { AccountChannelsRequest, AccountChannelsResponse, AccountCurrenciesRequest, AccountCurrenciesResponse, AccountInfoRequest, AccountInfoResponse, AccountLinesRequest, AccountLinesResponse, AccountNFTsRequest, AccountNFTsResponse, AccountObjectsRequest, AccountObjectsResponse, AccountOffersRequest, AccountOffersResponse, AccountTxRequest, AccountTxResponse, GatewayBalancesRequest, GatewayBalancesResponse, NoRippleCheckRequest, NoRippleCheckResponse, LedgerRequest, LedgerResponse, LedgerClosedRequest, LedgerClosedResponse, LedgerCurrentRequest, LedgerCurrentResponse, LedgerDataRequest, LedgerDataResponse, LedgerEntryRequest, LedgerEntryResponse, SubmitRequest, SubmitResponse, SubmitMultisignedRequest, SubmitMultisignedResponse, TransactionEntryRequest, TransactionEntryResponse, TxRequest, TxResponse, BookOffersRequest, BookOffersResponse, DepositAuthorizedRequest, DepositAuthorizedResponse, PathFindRequest, PathFindResponse, RipplePathFindRequest, RipplePathFindResponse, ChannelVerifyRequest, ChannelVerifyResponse, FeeRequest, FeeResponse, ManifestRequest, ManifestResponse, ServerInfoRequest, ServerInfoResponse, ServerStateRequest, ServerStateResponse, PingRequest, PingResponse, RandomRequest, RandomResponse, LedgerStream, ValidationStream, TransactionStream, PathFindStream, PeerStatusStream, ConsensusStream, SubscribeRequest, SubscribeResponse, UnsubscribeRequest, UnsubscribeResponse, NFTBuyOffersRequest, NFTBuyOffersResponse, NFTSellOffersRequest, NFTSellOffersResponse, NFTInfoRequest, NFTInfoResponse, NFTHistoryRequest, NFTHistoryResponse, AMMInfoRequest, AMMInfoResponse, ServerDefinitionsRequest, ServerDefinitionsResponse } from '../models/methods';
import { BaseRequest, BaseResponse } from '../models/methods/baseMethod';
import { autofill, getLedgerIndex, getOrderbook, getBalances, getXrpBalance, submit, submitAndWait } from '../sugar';
import fundWallet from '../Wallet/fundWallet';
import { Connection, ConnectionUserOptions } from './connection';
export interface ClientOptions extends ConnectionUserOptions {
    feeCushion?: number;
    maxFeeXRP?: string;
    proxy?: string;
    timeout?: number;
}
declare class Client extends EventEmitter {
    readonly connection: Connection;
    readonly feeCushion: number;
    readonly maxFeeXRP: string;
    networkID: number | undefined;
    buildVersion: string | undefined;
    constructor(server: string, options?: ClientOptions);
    get url(): string;
    request(r: AccountChannelsRequest): Promise<AccountChannelsResponse>;
    request(r: AccountCurrenciesRequest): Promise<AccountCurrenciesResponse>;
    request(r: AccountInfoRequest): Promise<AccountInfoResponse>;
    request(r: AccountLinesRequest): Promise<AccountLinesResponse>;
    request(r: AccountNFTsRequest): Promise<AccountNFTsResponse>;
    request(r: AccountObjectsRequest): Promise<AccountObjectsResponse>;
    request(r: AccountOffersRequest): Promise<AccountOffersResponse>;
    request(r: AccountTxRequest): Promise<AccountTxResponse>;
    request(r: AMMInfoRequest): Promise<AMMInfoResponse>;
    request(r: BookOffersRequest): Promise<BookOffersResponse>;
    request(r: ChannelVerifyRequest): Promise<ChannelVerifyResponse>;
    request(r: DepositAuthorizedRequest): Promise<DepositAuthorizedResponse>;
    request(r: FeeRequest): Promise<FeeResponse>;
    request(r: GatewayBalancesRequest): Promise<GatewayBalancesResponse>;
    request(r: LedgerRequest): Promise<LedgerResponse>;
    request(r: LedgerClosedRequest): Promise<LedgerClosedResponse>;
    request(r: LedgerCurrentRequest): Promise<LedgerCurrentResponse>;
    request(r: LedgerDataRequest): Promise<LedgerDataResponse>;
    request(r: LedgerEntryRequest): Promise<LedgerEntryResponse>;
    request(r: ManifestRequest): Promise<ManifestResponse>;
    request(r: NFTBuyOffersRequest): Promise<NFTBuyOffersResponse>;
    request(r: NFTSellOffersRequest): Promise<NFTSellOffersResponse>;
    request(r: NFTInfoRequest): Promise<NFTInfoResponse>;
    request(r: NFTHistoryRequest): Promise<NFTHistoryResponse>;
    request(r: NoRippleCheckRequest): Promise<NoRippleCheckResponse>;
    request(r: PathFindRequest): Promise<PathFindResponse>;
    request(r: PingRequest): Promise<PingResponse>;
    request(r: RandomRequest): Promise<RandomResponse>;
    request(r: RipplePathFindRequest): Promise<RipplePathFindResponse>;
    request(r: ServerDefinitionsRequest): Promise<ServerDefinitionsResponse>;
    request(r: ServerInfoRequest): Promise<ServerInfoResponse>;
    request(r: ServerStateRequest): Promise<ServerStateResponse>;
    request(r: SubmitRequest): Promise<SubmitResponse>;
    request(r: SubmitMultisignedRequest): Promise<SubmitMultisignedResponse>;
    request(r: SubscribeRequest): Promise<SubscribeResponse>;
    request(r: UnsubscribeRequest): Promise<UnsubscribeResponse>;
    request(r: TransactionEntryRequest): Promise<TransactionEntryResponse>;
    request(r: TxRequest): Promise<TxResponse>;
    request<R extends BaseRequest, T extends BaseResponse>(r: R): Promise<T>;
    requestNextPage(req: AccountChannelsRequest, resp: AccountChannelsResponse): Promise<AccountChannelsResponse>;
    requestNextPage(req: AccountLinesRequest, resp: AccountLinesResponse): Promise<AccountLinesResponse>;
    requestNextPage(req: AccountObjectsRequest, resp: AccountObjectsResponse): Promise<AccountObjectsResponse>;
    requestNextPage(req: AccountOffersRequest, resp: AccountOffersResponse): Promise<AccountOffersResponse>;
    requestNextPage(req: AccountTxRequest, resp: AccountTxResponse): Promise<AccountTxResponse>;
    requestNextPage(req: LedgerDataRequest, resp: LedgerDataResponse): Promise<LedgerDataResponse>;
    on(event: 'connected', listener: () => void): this;
    on(event: 'disconnected', listener: (code: number) => void): this;
    on(event: 'ledgerClosed', listener: (ledger: LedgerStream) => void): this;
    on(event: 'validationReceived', listener: (validation: ValidationStream) => void): this;
    on(event: 'transaction', listener: (tx: TransactionStream) => void): this;
    on(event: 'peerStatusChange', listener: (status: PeerStatusStream) => void): this;
    on(event: 'consensusPhase', listener: (phase: ConsensusStream) => void): this;
    on(event: 'manifestReceived', listener: (manifest: ManifestResponse) => void): this;
    on(event: 'path_find', listener: (path: PathFindStream) => void): this;
    on(event: 'error', listener: (...err: any[]) => void): this;
    requestAll(req: AccountChannelsRequest): Promise<AccountChannelsResponse[]>;
    requestAll(req: AccountLinesRequest): Promise<AccountLinesResponse[]>;
    requestAll(req: AccountObjectsRequest): Promise<AccountObjectsResponse[]>;
    requestAll(req: AccountOffersRequest): Promise<AccountOffersResponse[]>;
    requestAll(req: AccountTxRequest): Promise<AccountTxResponse[]>;
    requestAll(req: BookOffersRequest): Promise<BookOffersResponse[]>;
    requestAll(req: LedgerDataRequest): Promise<LedgerDataResponse[]>;
    getServerInfo(): Promise<void>;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    isConnected(): boolean;
    autofill: typeof autofill;
    submit: typeof submit;
    submitAndWait: typeof submitAndWait;
    prepareTransaction: typeof autofill;
    getXrpBalance: typeof getXrpBalance;
    getBalances: typeof getBalances;
    getOrderbook: typeof getOrderbook;
    getLedgerIndex: typeof getLedgerIndex;
    fundWallet: typeof fundWallet;
}
export { Client };
//# sourceMappingURL=index.d.ts.map